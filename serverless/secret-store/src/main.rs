mod config;
mod constants;
mod events;
mod model;
mod scheduler;
mod server;
mod utils;

use std::collections::HashMap;
use std::sync::{Arc, RwLock};

use actix_web::http::Uri;
use actix_web::web::Data;
use actix_web::{App, HttpServer};
use alloy::primitives::Address;
use alloy::providers::ProviderBuilder;
use alloy::signers::k256::ecdsa::SigningKey;
use alloy::signers::utils::public_key_to_address;
use alloy::transports::http::reqwest::Url;
use anyhow::{Context, Result};
use clap::Parser;
use tokio::fs;

use model::{AppState, ConfigManager, SecretManagerContract};
use server::*;
use utils::verify_rpc_url;

// SECRET STORE CONFIGURATION PARAMETERS
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// External port to expose outside enclave for injecting secret
    #[clap(long, value_parser, default_value = "6002")]
    external_port: u16,

    // Path to the configuration file
    #[clap(
        long,
        value_parser,
        default_value = "./oyster_secret_store_config.json"
    )]
    config_file: String,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Cli::parse();
    let config_manager = ConfigManager::new(&args.config_file);
    let mut config = config_manager.load_config().unwrap();

    verify_rpc_url(&config.http_rpc_url).context("Invalid RPC URL")?;

    // Read the 'secp256k1' private key of the enclave instance generated by keygen
    let enclave_signer_key = SigningKey::from_slice(
        fs::read(config.enclave_signer_file)
            .await
            .context("Failed to read the enclave signer key")?
            .as_slice(),
    )
    .context("Invalid enclave signer key")?;

    let enclave_address = public_key_to_address(&enclave_signer_key.verifying_key());
    println!("Enclave address {:?}", enclave_address);

    let http_rpc_client = ProviderBuilder::new()
        .on_http(Url::parse(&config.http_rpc_url).context("Failed to parse the RPC URL")?);
    let secret_manager_contract =
        SecretManagerContract::new(config.secret_manager_contract_addr, http_rpc_client);

    // Validate the format of the web_socket_url
    let _ = config
        .web_socket_url
        .parse::<Uri>()
        .context("Invalid web_socket_url format")?;
    if !config.web_socket_url.ends_with('/') {
        config.web_socket_url.push('/');
    }

    // Initialize App data that will be shared across multiple threads and tasks
    let app_data = Data::new(AppState {
        secret_store_path: config.secret_store_path,
        common_chain_id: config.common_chain_id,
        http_rpc_url: config.http_rpc_url,
        web_socket_url: Arc::new(RwLock::new(config.web_socket_url)),
        tee_manager_contract_addr: config.tee_manager_contract_addr,
        secret_manager_contract_addr: config.secret_manager_contract_addr,
        secret_manager_contract_instance: secret_manager_contract,
        num_selected_stores: config.num_selected_stores,
        enclave_address: enclave_address,
        enclave_signer: enclave_signer_key,
        immutable_params_injected: false.into(),
        mutable_params_injected: false.into(),
        enclave_owner: Address::ZERO.into(),
        http_rpc_txn_manager: None.into(),
        enclave_registered: false.into(),
        events_listener_active: false.into(),
        enclave_draining: false.into(),
        last_block_seen: 0.into(),
        acknowledgement_timeout: config.acknowledgement_timeout,
        mark_alive_timeout: config.mark_alive_timeout,
        secrets_awaiting_acknowledgement: HashMap::new().into(),
        secrets_created: HashMap::new().into(),
        secrets_stored: HashMap::new().into(),
    });

    let app_data_clone = app_data.clone();
    // Start actix server to expose the secret store API endpoints for configuration and registration requests inside the enclave local system
    let config_server = HttpServer::new(move || {
        App::new()
            .app_data(app_data_clone.clone())
            .service(index)
            .service(inject_immutable_config)
            .service(inject_mutable_config)
            .service(get_secret_store_details)
            .service(export_registration_details)
    })
    .bind(("0.0.0.0", config.config_port))
    .context(format!("could not bind to port {}", config.config_port))?
    .run();

    println!("Config server started on port {}", config.config_port);

    // Start actix server to expose the inject secret endpoint outside the enclave
    let external_server = HttpServer::new(move || {
        App::new()
            .app_data(app_data.clone())
            .service(inject_and_store_secret)
    })
    .bind(("0.0.0.0", args.external_port))
    .context(format!("could not bind to port {}", args.external_port))?
    .run();

    println!(
        "Secret inject server started on port {}",
        args.external_port
    );

    // Run both servers concurrently
    tokio::try_join!(config_server, external_server)?;

    Ok(())
}
